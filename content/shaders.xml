<shaders>
    <shader name="HudHelperEmptyShader">
        <vertex><![CDATA[
            attribute vec3 Position;
            attribute vec4 Color;
            attribute vec2 TexCoord;
            varying vec4 Color0;
            varying vec2 TexCoord0;
            uniform mat4 Transform;
            void main(void) {
                Color0 = Color;
                TexCoord0 = TexCoord;
                gl_Position = Transform * vec4(Position.xyz, 1.0);
            }
        ]]></vertex>
        <fragment><![CDATA[
            varying lowp vec4 Color0;
            varying mediump vec2 TexCoord0;
            uniform sampler2D Texture0;
            void main(void) {
                vec4 Color = Color0 * texture2D(Texture0, TexCoord0);
                gl_FragColor = Color;
            }
        ]]></fragment>
    </shader>
    <shader name="ResouledBlankCanvas">
        <parameters>
            <param name="AnchorPos" type="vec2"/>
            <param name="Point1" type="vec2"/>
            <param name="Point2" type="vec2"/>
            <param name="Point3" type="vec2"/>
            <param name="Point4" type="vec2"/>
            <param name="Point5" type="vec2"/>
            <param name="Point6" type="vec2"/>
            <param name="Point7" type="vec2"/>
        </parameters>
        <vertex><![CDATA[
            attribute vec3 Position;
            attribute vec4 Color;
            attribute vec2 TexCoord;
            attribute vec4 RenderData;
            attribute float Scale;
            attribute vec2 AnchorPos;
            attribute vec2 Point1;
            attribute vec2 Point2;
            attribute vec2 Point3;
            attribute vec2 Point4;
            attribute vec2 Point5;
            attribute vec2 Point6;
            attribute vec2 Point7;
            vec2 Pos = vec2(Position.xy);
            varying vec4 Color0;
            varying vec2 TexCoord0;
            varying vec4 RenderDataOut;
            varying float ScaleOut;
            varying vec2 AnchorPosOut;
            varying vec2 PosOut;
            varying vec2 Point1Out;
            varying vec2 Point2Out;
            varying vec2 Point3Out;
            varying vec2 Point4Out;
            varying vec2 Point5Out;
            varying vec2 Point6Out;
            varying vec2 Point7Out;
            uniform mat4 Transform;
            void main(void)
            {
                RenderDataOut = RenderData;
                ScaleOut = Scale;
                Color0 = Color;
                TexCoord0 = TexCoord;
                AnchorPosOut = AnchorPos;
                PosOut = Pos;
                Point1Out = Point1;
                Point2Out = Point2;
                Point3Out = Point3;
                Point4Out = Point4;
                Point5Out = Point5;
                Point6Out = Point6;
                Point7Out = Point7;
                gl_Position = Transform * vec4(Position.xyz, 1.0);
            }
        ]]></vertex>
        <fragment><![CDATA[
            varying lowp vec4 Color0;
            varying mediump vec2 TexCoord0;
            varying lowp vec4 RenderDataOut;
            varying lowp float ScaleOut;
            varying lowp vec2 AnchorPosOut;
            varying lowp vec2 PosOut;
            varying lowp vec2 Point1Out;
            varying lowp vec2 Point2Out;
            varying lowp vec2 Point3Out;
            varying lowp vec2 Point4Out;
            varying lowp vec2 Point5Out;
            varying lowp vec2 Point6Out;
            varying lowp vec2 Point7Out;
            uniform sampler2D Texture0;

            vec2 getPoint(int n)
            {
                if (n == 1) {return Point1Out;}
                if (n == 2) {return Point2Out;}
                if (n == 3) {return Point3Out;}
                if (n == 4) {return Point4Out;}
                if (n == 5) {return Point5Out;}
                if (n == 6) {return Point6Out;}
                if (n == 7) {return Point7Out;}
                return vec2(0, 0);
            }

            vec2 getLastPoint(int n, int max)
            {
                n = n - 1;
                if (n < 1) {
                    n = max + n;
                }

                if (n == 1) {return Point1Out;}
                if (n == 2) {return Point2Out;}
                if (n == 3) {return Point3Out;}
                if (n == 4) {return Point4Out;}
                if (n == 5) {return Point5Out;}
                if (n == 6) {return Point6Out;}
                if (n == 7) {return Point7Out;}
                return vec2(0, 0);
            }

            vec2 getNextPoint(int n, int max)
            {
                n = n + 1;
                if (n > max) {
                    n = n - max;
                }

                if (n == 1) {return Point1Out;}
                if (n == 2) {return Point2Out;}
                if (n == 3) {return Point3Out;}
                if (n == 4) {return Point4Out;}
                if (n == 5) {return Point5Out;}
                if (n == 6) {return Point6Out;}
                if (n == 7) {return Point7Out;}
                return vec2(0, 0);
            }

            float getAngleDegrees(vec2 v) {
                return degrees(atan(v.y, v.x));
            }

            vec2 rotate(vec2 v, float a) {
                a = radians(a);
	            float s = sin(a);
	            float c = cos(a);
	            mat2 m = mat2(c, s, -s, c);
	            return m * v;
            }

            void main(void)
            {
                vec4 Color = Color0 * texture2D(Texture0, TexCoord0);

                int sides = 0;
                if (Point1Out.x != 0 && Point1Out.y != 0) {sides++;}
                if (Point2Out.x != 0 && Point2Out.y != 0) {sides++;}
                if (Point3Out.x != 0 && Point3Out.y != 0) {sides++;}
                if (Point4Out.x != 0 && Point4Out.y != 0) {sides++;}
                if (Point5Out.x != 0 && Point5Out.y != 0) {sides++;}
                if (Point6Out.x != 0 && Point6Out.y != 0) {sides++;}
                if (Point7Out.x != 0 && Point7Out.y != 0) {sides++;}

                if (sides >= 3) {
                    vec2 Anchor = AnchorPosOut;
                    vec2 pos = PosOut - Anchor;
                    bool isInside = true;
                    bool isInsideOutline = true;

                    for (int i = 1; i <= sides; i++) {
                        vec2 sidePos = getPoint(i);
                        vec2 lastPos = getLastPoint(i, sides);
                        vec2 nextPos = getNextPoint(i, sides);
                        float anchorToSidePos = getAngleDegrees(sidePos);

                        float lastPosDegrees = getAngleDegrees(rotate(lastPos - sidePos, -anchorToSidePos));
                        float nextPosDegrees = getAngleDegrees(rotate(nextPos - sidePos, -anchorToSidePos));
                        float toPointDegrees = getAngleDegrees(rotate(pos - sidePos, -anchorToSidePos));

                        if ((toPointDegrees >= nextPosDegrees == false) && (toPointDegrees <= lastPosDegrees == false)) {
                            isInside = false;
                            break;
                        }
                    }

                    for (int i = 1; i <= sides; i++) {
                        vec2 sidePos = getPoint(i) * 1.025;
                        vec2 lastPos = getLastPoint(i, sides) * 1.1;
                        vec2 nextPos = getNextPoint(i, sides) * 1.1;
                        float anchorToSidePos = getAngleDegrees(sidePos);

                        float lastPosDegrees = getAngleDegrees(rotate(lastPos - sidePos, -anchorToSidePos));
                        float nextPosDegrees = getAngleDegrees(rotate(nextPos - sidePos, -anchorToSidePos));
                        float toPointDegrees = getAngleDegrees(rotate(pos - sidePos, -anchorToSidePos));

                        if ((toPointDegrees >= nextPosDegrees == false) && (toPointDegrees <= lastPosDegrees == false)) {
                            isInsideOutline = false;
                            break;
                        }
                    }

                    if (isInside == true) {
                        vec4 ColorHelper = Color0 * texture2D(Texture0, TexCoord0);

                        ColorHelper.r *= 0.25 + ColorHelper.r;
                        ColorHelper.g *= 0.3 + ColorHelper.g;
                        ColorHelper.b *= 0.3 + ColorHelper.b;
                        ColorHelper.r += 0.22;
                        ColorHelper.g += 0.215;
                        ColorHelper.b += 0.215;

                        float similarityTo1stColor = abs(-ColorHelper.r -ColorHelper.g -ColorHelper.b);
                        float similarityTo2ndColor = abs(0.674 - ColorHelper.r + 0.549 - ColorHelper.g + 0.549 - ColorHelper.b);
                        float similarityTo3rdColor = abs(0.894 - ColorHelper.r + 0.871 - ColorHelper.g + 0.839 - ColorHelper.b);

                        if (similarityTo1stColor < similarityTo2ndColor) {
                            Color.r += 0 - Color.r;
                            Color.g += 0 - Color.g;
                            Color.b += 0 - Color.b;
                        } else if (similarityTo2ndColor < similarityTo1stColor && similarityTo2ndColor < similarityTo3rdColor) {
                            Color.r += 0.674 - Color.r;
                            Color.g += 0.549 - Color.g;
                            Color.b += 0.549 - Color.b;
                        } else {
                            Color.r += 0.894 - Color.r;
                            Color.g += 0.871 - Color.g;
                            Color.b += 0.839 - Color.b;
                        }
                    } else if (isInsideOutline == true) {
                        Color.r = 0;
                        Color.g = 0;
                        Color.b = 0;
                    }
                }

                gl_FragColor = Color;
            }
        ]]></fragment>
    </shader>
</shaders>